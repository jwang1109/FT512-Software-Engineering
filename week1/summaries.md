# Your paper and video summaries go here.
Brooks, "No Silver Bullet Essence and Accidents of Software Engineering," in Computer, vol. 20, no. 4, pp. 10-19, April 1987, doi: 10.1109/MC.1987.1663532.

Keywords: complexity, essence, software development, AI, technology breakthrough, productivity, software design

Summary:
The author believes technology or management innovation can be no 'silver bullet' to address the essence of software engineering problems. He introduces four essences of software and tries to persuade readers that some new methodologies, tools, and technology may be helpful only to some extent in the future but not promising. However, the author believes some hopeful signs of progress can be made by establishing a mass market, applying incremental development, rapid prototyping, and cultivating good designers.

Strengths:
1. The author persuades readers clearly and logically. He first introduces four essences of software problems and stresses that they are not accidental while most of the management or technology innovations are just attacks on accidental ones.

2. Some of his arguments are both high-level and strong. For example, when arguing that graphical programming can be no silver bullet, he pointed out that the screen size is too small for a complex software diagram.

Weaknesses:

1. The article was written in 1986, and it seems to undervalue the progress AI would make. Chat Gpt can serve as a good counterexample.

2. The article needs proper introductions to some terminologies. Brooks presumes readers are familiar with all these terminologies and know exactly what those words represent. For example, I still need to find out apart from an expert system and AI by reading his introduction.

3. The 'promising progress' he suggested in these articles is so vanilla to me. Even if he doesn't point out those progresses, people would still think twice when making a purchase or construction decision. Also, cultivating great designers is just an over-generalized suggestion and can always be true.






Bob Frankston,Implementing VisCalc, https://rmf.vc/ImplementingVisiCalc
Keywords: the principle of least surprising, interface, software design, user-friendly

Summary:
Bob Frankston wrote about his project experience of developing VisiCalc. He introduced how and why he designed VisiCalc like that. He considers VisiCalc to be more than software but also a product, so he applied the principle of least surprising and prototyping. He also emphasized team cooperation and a user-friendly physical interface (screen display, keyboard). One of his user-friendly design is to give the user the illusion that they can use the software with imagination, even if only a few choices are allowed to use a few choices in that context.
 
Strength:
1. Bob concludes with several principles to follow in software development, which are still highly useful. And I would like to remember some of those rules when I am building a software.
2. Bob detailly recorded the logic behind a decision that was made, which encourages me to apply his similar logic.

Weakness:
1.  VisiCalc is an old program, and some terminologies and technical considerations need to be clarified for me. Sometimes, it's hard for me to understand how clever the design is if I am not familiar with the terminology.

Comment
1. Bob's experience taught me on how important the self-study is for a programmer. He had to find and read a new book in order to implement @sin function. This encourages me to accept life-long learning as an engineer.







Grady Booch, CHM Live | The History (and the Future) of Software, https://www.youtube.com/watch?v=OdI7Ukf-Bf4

Keywords: software, hardware, history, programming methodology, Internet of things, agile development, waterfall development

Summary
 The lecture takes the audience on a journey to explore the story of software. He mainly separates the story into three parts. First, in the numeric phase, when computers were still largely dependent on humans, software was just mathematic computation. Then, the business and new technology brought the software into the symbolic phase, when software diverges from hardware and can control itself. This was also the time when various programming languages emerged. After that, thanks to the advance of microprocessors and the divergence of processes and humans, software gets into the "mirror world" phase when people try to put the whole universe into it. The author also introduced OOD, the Internet of things, and neural networks as trends.

Strength:
1. Great generalization. He separates the history of software mainly into three phases. Numeric, symbolic, and "mirror world."
2. The lecture shows his view from an anthropology perspective. For example, he thinks the business after war helps the software evolute to the next stage. 
3. The lecturer maintains an objective perspective; he shows how women contributed to the computer in the early stage. I've never been taught about that.

Weakness:
4. The lecturer believes software and hardware have diverged and put too much emphasis on the independence of hardware and software. I noticed that he didn't mention quantum computers. For me, this hardware innovation may drive software evolution again.


# Rubric:
* Write a short summary of the paper/video, as follows:
* First line: Paper Title, citation source
* Keywords: List keywords from paper, or select 4-8 most relevant terms from the paper
* First paragraph: describe the main points of the paper/video.
* Second paragraph: Present the paper/video's strengths and weaknesses from your point of view.


